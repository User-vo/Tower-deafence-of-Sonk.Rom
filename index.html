<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0">
    <title>Sonk.Rom TD ‚Äî –¢–∞–π–º–∞—É—Ç –≤—Ä–∞–≥–∞ 1 –º–∏–Ω—É—Ç–∞</title>
    <style>
        /* –°—Ç–∏–ª–∏ Windows 95 ‚Äî –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
        body {
            background: #008080;
            font-family: 'MS Sans Serif', 'Microsoft Sans Serif', 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .window {
            background: #c0c0c0;
            border: 4px solid;
            border-color: #ffffff #404040 #404040 #ffffff;
            padding: 4px;
            display: inline-block;
            max-width: 100%;
        }
        .title-bar {
            background: #000080;
            color: white;
            padding: 4px 8px;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            border: 2px solid;
            border-color: #ffffff #404040 #404040 #ffffff;
            margin-bottom: 10px;
        }
        .game-container {
            display: flex;
            gap: 20px;
            flex-wrap: nowrap;
            align-items: flex-start;
            overflow-x: auto;
            max-width: 100%;
            padding-bottom: 5px;
        }
        canvas {
            border: 4px solid;
            border-color: #404040 #ffffff #ffffff #404040;
            background: #e0e0e0;
            cursor: crosshair;
            width: 760px;
            height: 520px;
            max-width: none;
            flex-shrink: 0;
            display: block;
        }
        .panel {
            width: 320px;
            background: #c0c0c0;
            border: 4px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            padding: 12px;
            font-size: 16px;
            flex-shrink: 0;
        }
        .sonk-rom {
            background: #0000aa;
            color: yellow;
            padding: 8px;
            margin-bottom: 12px;
            border: 3px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }
        .sonk-rom span { font-size: 32px; }
        .shop-item {
            background: #d0d0d0;
            border: 3px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .shop-item button {
            background: #c0c0c0;
            border: 4px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            font-family: inherit;
            font-size: 16px;
            padding: 6px 12px;
            cursor: pointer;
            font-weight: bold;
        }
        .shop-item button:active {
            border-color: #808080 #ffffff #ffffff #808080;
        }
        .health-bar {
            background: #ff0000;
            height: 20px;
            width: 100%;
            border: 2px solid #404040;
        }
        .health-fill {
            background: #00aa00;
            height: 100%;
            width: 100%;
            transition: width 0.1s;
        }
        .upgrade-menu {
            background: #ffffcc;
            border: 4px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            padding: 8px;
            margin-top: 12px;
            font-size: 14px;
        }
        .restart-btn {
            background: #c0c0c0;
            border: 4px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            font-size: 18px;
            padding: 8px 16px;
            margin-top: 12px;
            width: 100%;
            cursor: pointer;
            font-weight: bold;
        }
        .restart-btn:active {
            border-color: #808080 #ffffff #ffffff #808080;
        }
    </style>
</head>
<body>
    <div class="window">
        <div class="title-bar">
            <span>ü¶î Sonk.Rom TD ‚Äî –¢–∞–π–º–∞—É—Ç –≤—Ä–∞–≥–∞ 1 –º–∏–Ω—É—Ç–∞</span>
            <span>üìü Win95</span>
        </div>
        <div class="game-container">
            <canvas id="gameCanvas" width="760" height="520"></canvas>

            <div class="panel">
                <div class="sonk-rom">
                    <span>ü¶î</span> Sonk.Rom <span style="font-size:14px;">v8.1</span>
                </div>
                
                <div style="margin-bottom: 12px; font-weight: bold;">
                    üí∞ –ú–æ–Ω–µ—Ç—ã: <span id="moneyDisplay">200</span>
                </div>
                <div style="margin-bottom: 12px;">
                    üè∞ –ë–∞–∑–∞: <span id="baseHealthDisplay">100</span> HP
                    <div class="health-bar">
                        <div id="baseHealthFill" class="health-fill" style="width:100%;"></div>
                    </div>
                </div>
                <div style="margin-bottom: 12px; font-weight: bold; background:#000080; color:white; padding:4px;">
                    üåä –í–û–õ–ù–ê: <span id="waveDisplay">1</span> &nbsp;|&nbsp; üèÜ –†–µ–∫–æ—Ä–¥: <span id="recordDisplay">1</span>
                </div>

                <h3 style="margin:0 0 8px 0; border-bottom:2px solid #808080;">üè™ –ú–ê–ì–ê–ó–ò–ù</h3>
                
                <div class="shop-item">
                    <div>
                        <strong>üî´ –°—Ç—Ä–µ–ª–æ–∫</strong><br>
                        <span style="font-size:14px;">–£—Ä6 –°–∫2 –î–µ–±2 (–ø–æ–¥–∂–æ–≥)</span>
                    </div>
                    <button onclick="selectTower(0)">80üí∞</button>
                </div>
                <div class="shop-item">
                    <div>
                        <strong>üêå –ó–∞–º–µ–¥–ª–∏—Ç–µ–ª—å</strong><br>
                        <span style="font-size:14px;">–£—Ä2 –°–∫4 –î–µ–±4 (–∑–∞–º–µ–¥–ª)</span>
                    </div>
                    <button onclick="selectTower(1)">90üí∞</button>
                </div>
                <div class="shop-item">
                    <div>
                        <strong>üî• –ü–æ–¥–∂–∏–≥–∞—Ç–µ–ª—å</strong><br>
                        <span style="font-size:14px;">–£—Ä4 –°–∫3 –î–µ–±3 (–æ–≥–æ–Ω—å)</span>
                    </div>
                    <button onclick="selectTower(2)">85üí∞</button>
                </div>

                <div style="margin-top:16px; font-size:14px; background:#ffffaa; padding:6px; border:2px solid #808080;">
                    üÜì –ü–ï–†–í–ê–Ø –ë–ê–®–ù–Ø ‚Äî –ë–ï–°–ü–õ–ê–¢–ù–û!<br>
                    üñ±Ô∏è –ö–ª–∏–∫ –ø–æ –±–∞—à–Ω–µ ‚Äî —É–ª—É—á—à–µ–Ω–∏–µ<br>
                    ‚è±Ô∏è 1 –±–∞–ª–ª –°–∫–ê—Ç–∞–∫–∏ = 2 —Å–µ–∫<br>
                    ‚è≥ –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ 1-–π –≤–æ–ª–Ω–æ–π: 2 —Å–µ–∫<br>
                    ‚è∞ –¢–∞–π–º–∞—É—Ç –≤—Ä–∞–≥–∞: 1 –º–∏–Ω—É—Ç–∞
                </div>

                <div id="upgradePanel" class="upgrade-menu" style="display:none;">
                    <div style="font-weight:bold; margin-bottom:8px;">üîß –£–ª—É—á—à–∏—Ç—å –±–∞—à–Ω—é</div>
                    <div style="display:flex; justify-content:space-between;">
                        <button id="upgradeDamageBtn" style="width:30%;">üí• +1 —É—Ä–æ–Ω (50üí∞)</button>
                        <button id="upgradeSpeedBtn" style="width:30%;">‚ö° +1 —Å–∫.–∞—Ç–∞–∫–∏ (50üí∞)</button>
                        <button id="upgradeDebuffBtn" style="width:30%;">üß™ +1 –¥–µ–±–∞—Ñ—Ñ (50üí∞)</button>
                    </div>
                    <div style="margin-top:8px;">
                        <span id="selectedTowerInfo">(–≤—ã–±–µ—Ä–∏—Ç–µ –±–∞—à–Ω—é)</span>
                    </div>
                </div>

                <button class="restart-btn" onclick="restartGame()">üîÑ –ù–û–í–ê–Ø –ò–ì–†–ê</button>
            </div>
        </div>
    </div>

    <script>
        // ------------------------------------------------------------
        //  –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ê–†–ê–ú–ï–¢–†–´
        // ------------------------------------------------------------
        const COLS = 12, ROWS = 8, CELL_SIZE = 60;
        const CANVAS_WIDTH = COLS * CELL_SIZE + 40;
        const CANVAS_HEIGHT = ROWS * CELL_SIZE + 40;

        // ------------------------------------------------------------
        //  –¢–û–ß–ö–ò –ú–ê–†–®–†–£–¢–ê (–ü–û–õ–ù–´–ô –ò–ó–í–ò–õ–ò–°–¢–´–ô –ü–£–¢–¨)
        // ------------------------------------------------------------
        const waypoints = [
            { col: 0, row: 3 }, { col: 1, row: 3 }, { col: 2, row: 3 }, { col: 3, row: 3 }, { col: 4, row: 3 },
            { col: 4, row: 4 }, { col: 4, row: 5 },
            { col: 5, row: 5 }, { col: 6, row: 5 }, { col: 7, row: 5 }, { col: 8, row: 5 },
            { col: 8, row: 4 }, { col: 8, row: 3 }, { col: 8, row: 2 },
            { col: 9, row: 2 }, { col: 10, row: 2 }, { col: 11, row: 2 } // –ë–ê–ó–ê
        ];

        // –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–û–ï –ü–û–°–¢–†–û–ï–ù–ò–ï –°–ï–¢–ö–ò
        const gridMap = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        waypoints.forEach((point, index) => {
            const { row, col } = point;
            gridMap[row][col] = (index === waypoints.length - 1) ? 2 : 1;
        });

        // ---------- –¢–ò–ü–´ –Æ–ù–ò–¢–û–í ----------
        const TOWER_TYPES = [
            { name: '–°—Ç—Ä–µ–ª–æ–∫', damage: 6, attackSpeed: 2, debuff: 2, debuffType: 'burn', price: 80, color: '#5050ff' },
            { name: '–ó–∞–º–µ–¥–ª–∏—Ç–µ–ª—å', damage: 2, attackSpeed: 4, debuff: 4, debuffType: 'slow', price: 90, color: '#50c050' },
            { name: '–ü–æ–¥–∂–∏–≥–∞—Ç–µ–ª—å', damage: 4, attackSpeed: 3, debuff: 3, debuffType: 'burn', price: 85, color: '#ff8844' }
        ];

        // ---------- –í–†–ê–ì–ò ----------
        const ENEMY_BASE = [
            { name: '–ü–µ—Ö–æ—Ç–∏–Ω–µ—Ü', baseHp: 25, baseSpeed: 0.9, reward: 25, color: '#8b4513' },
            { name: '–ë—Ä–æ–Ω–µ–Ω–æ—Å–µ—Ü', baseHp: 55, baseSpeed: 0.5, reward: 45, color: '#555555' },
            { name: '–ö—É—Ä—å–µ—Ä', baseHp: 18, baseSpeed: 1.8, reward: 30, color: '#ffaa00', slowResist: 0.5 }
        ];

        // ---------- –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ò–ì–†–´ ----------
        let money = 200;
        let baseHealth = 100;
        let maxBaseHealth = 100;
        let selectedTowerIndex = 0;
        let gameOver = false;
        let towers = [];
        let enemies = [];

        let wave = 1;
        let enemiesSpawnedThisWave = 0;
        let enemiesPerWave = 8;
        let spawnDelay = 50;
        let spawnCounter = 0;
        let frame = 0;
        let startDelay = 120; // 2 —Å–µ–∫—É–Ω–¥—ã

        let maxWaveRecord = localStorage.getItem('sonktd_maxwave') ? parseInt(localStorage.getItem('sonktd_maxwave')) : 1;
        let selectedTowerForUpgrade = null;

        // ---------- –ó–í–£–ö–ò ----------
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'square';
            if (type === 'kill') {
                osc.frequency.value = 220;
                gain.gain.value = 0.15;
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'basehit') {
                osc.frequency.value = 100;
                gain.gain.value = 0.2;
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            } else if (type === 'buy') {
                osc.frequency.value = 660;
                gain.gain.value = 0.1;
                osc.start();
                osc.stop(audioCtx.currentTime + 0.07);
            }
        }

        // ---------- –ö–õ–ê–°–° –ë–ê–®–ù–ò ----------
        class Tower {
            constructor(col, row, typeIndex) {
                this.col = col; this.row = row;
                this.typeIndex = typeIndex;
                this.baseType = TOWER_TYPES[typeIndex];
                this.damage = this.baseType.damage;
                this.attackSpeed = this.baseType.attackSpeed;
                this.debuff = this.baseType.debuff;
                this.debuffType = this.baseType.debuffType;
                this.color = this.baseType.color;
                this.cooldown = 0;
                this.range = 1.7 * CELL_SIZE;
                this.upgradeDamageCost = 50;
                this.upgradeSpeedCost = 50;
                this.upgradeDebuffCost = 50;
            }
            getAttackIntervalFrames() {
                return Math.max(5, Math.floor(120 / this.attackSpeed));
            }
            update() {
                if (this.cooldown > 0) this.cooldown--;
                if (this.cooldown <= 0) {
                    let target = null;
                    let minDist = Infinity;
                    const tx = this.col * CELL_SIZE + CELL_SIZE/2 + 20;
                    const ty = this.row * CELL_SIZE + CELL_SIZE/2 + 20;
                    for (let enemy of enemies) {
                        const dx = enemy.x - tx, dy = enemy.y - ty;
                        const dist = Math.hypot(dx, dy);
                        if (dist < this.range && dist < minDist) {
                            minDist = dist; target = enemy;
                        }
                    }
                    if (target) {
                        target.takeDamage(this.damage);
                        if (this.debuff > 0) {
                            if (this.debuffType === 'slow') {
                                let factor = this.debuff * 0.07;
                                if (target.typeIndex === 2) factor *= 0.5;
                                target.applySlow(factor, 35);
                            } else if (this.debuffType === 'burn') {
                                target.applyBurn(this.debuff * 0.9, 25);
                            }
                        }
                        this.cooldown = this.getAttackIntervalFrames();
                    }
                }
            }
            upgradeDamage() { if (this.damage < this.baseType.damage + 5) { this.damage++; return true; } return false; }
            upgradeAttackSpeed() { if (this.attackSpeed < this.baseType.attackSpeed + 5) { this.attackSpeed++; return true; } return false; }
            upgradeDebuff() { if (this.debuff < this.baseType.debuff + 5) { this.debuff++; return true; } return false; }
        }

        // ---------- –ö–õ–ê–°–° –í–†–ê–ì–ê (–¢–ê–ô–ú–ê–£–¢ 1 –ú–ò–ù–£–¢–ê = 3600 –ö–ê–î–†–û–í) ----------
        class Enemy {
            constructor(typeIndex, waypoints, wave) {
                this.typeIndex = typeIndex;
                const base = ENEMY_BASE[typeIndex];
                const waveBonusHp = 1 + (wave - 1) * 0.15;
                const waveBonusSpeed = 1 + (wave - 1) * 0.03;
                this.hp = Math.floor(base.baseHp * waveBonusHp);
                this.maxHp = this.hp;
                this.speed = base.baseSpeed * waveBonusSpeed;
                this.reward = base.reward;
                this.color = base.color;
                this.slowResist = base.slowResist || 1.0;
                this.waypoints = [...waypoints];
                this.currentTargetIndex = 1;
                this.x = waypoints[0].col * CELL_SIZE + CELL_SIZE/2 + 20;
                this.y = waypoints[0].row * CELL_SIZE + CELL_SIZE/2 + 20;
                this.slowFactor = 1.0;
                this.slowTimer = 0;
                this.burnDamage = 0;
                this.burnTimer = 0;
                // –¢–ê–ô–ú–ê–£–¢: 1 –º–∏–Ω—É—Ç–∞ –ø—Ä–∏ 60 FPS
                this.age = 0;
                this.MAX_AGE = 3600; // 60 * 60 = 3600 –∫–∞–¥—Ä–æ–≤
            }

            move() {
                if (this.currentTargetIndex >= this.waypoints.length) return;
                const target = this.waypoints[this.currentTargetIndex];
                const targetX = target.col * CELL_SIZE + CELL_SIZE/2 + 20;
                const targetY = target.row * CELL_SIZE + CELL_SIZE/2 + 20;
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.hypot(dx, dy);
                
                if (distance < 8) {
                    this.currentTargetIndex++;
                } else {
                    const moveSpeed = this.speed * this.slowFactor * 1.2;
                    const normX = dx / distance;
                    const normY = dy / distance;
                    this.x += normX * moveSpeed;
                    this.y += normY * moveSpeed;
                }
            }

            takeDamage(amount) { this.hp -= amount; if (this.hp < 0) this.hp = 0; }
            applySlow(factor, duration) {
                this.slowFactor = Math.max(0.3, 1.0 - factor * this.slowResist);
                this.slowTimer = duration;
            }
            applyBurn(damage, duration) {
                this.burnDamage = Math.max(this.burnDamage, damage);
                this.burnTimer = duration;
            }
            updateEffects() {
                if (this.slowTimer > 0) {
                    this.slowTimer--;
                    if (this.slowTimer <= 0) this.slowFactor = 1.0;
                }
                if (this.burnTimer > 0) {
                    this.hp -= this.burnDamage;
                    this.burnTimer--;
                    if (this.burnTimer <= 0) this.burnDamage = 0;
                }
                this.age++;
            }

            isAlive() { return this.hp > 0; }
            isAtBase() { return this.currentTargetIndex >= this.waypoints.length; }
            isTooOld() { return this.age > this.MAX_AGE; }
        }

        // ---------- CANVAS ----------
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ---------- –û–¢–†–ò–°–û–í–ö–ê ----------
        function drawGrid() {
            ctx.fillStyle = '#e0e0e0';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    let x = col * CELL_SIZE + 20;
                    let y = row * CELL_SIZE + 20;
                    const cell = gridMap[row][col];
                    if (cell === 1) {
                        ctx.fillStyle = '#a0a0a0';
                        ctx.fillRect(x, y, CELL_SIZE-2, CELL_SIZE-2);
                        ctx.fillStyle = '#808080';
                        ctx.fillRect(x+2, y+2, CELL_SIZE-6, CELL_SIZE-6);
                    } else if (cell === 2) {
                        ctx.fillStyle = '#c00000';
                        ctx.fillRect(x, y, CELL_SIZE-2, CELL_SIZE-2);
                        ctx.fillStyle = '#900000';
                        ctx.fillRect(x+2, y+2, CELL_SIZE-6, CELL_SIZE-6);
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x+1, y+1, CELL_SIZE-4, CELL_SIZE-4);
                        ctx.strokeStyle = '#404040';
                        ctx.lineWidth = 1;
                        ctx.fillStyle = 'white';
                        ctx.font = '22px "MS Sans Serif"';
                        ctx.fillText('üè∞', x+15, y+45);
                        ctx.font = '12px "MS Sans Serif"';
                        ctx.fillStyle = 'yellow';
                        ctx.fillText(`HP: ${Math.floor(baseHealth)}`, x+5, y-5);
                    } else {
                        ctx.fillStyle = '#70b070';
                        ctx.fillRect(x, y, CELL_SIZE-2, CELL_SIZE-2);
                        ctx.fillStyle = '#509050';
                        ctx.fillRect(x+2, y+2, CELL_SIZE-6, CELL_SIZE-6);
                    }
                    ctx.strokeStyle = '#404040';
                    ctx.strokeRect(x, y, CELL_SIZE-2, CELL_SIZE-2);
                }
            }
        }

        function drawTowers() {
            for (let t of towers) {
                let x = t.col * CELL_SIZE + 20;
                let y = t.row * CELL_SIZE + 20;
                ctx.fillStyle = t.color;
                ctx.shadowBlur = 4;
                ctx.fillRect(x+8, y+8, CELL_SIZE-20, CELL_SIZE-20);
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'black';
                ctx.font = '16px "MS Sans Serif"';
                ctx.fillText('‚öôÔ∏è', x+15, y+42);
                ctx.font = '10px "MS Sans Serif"';
                ctx.fillStyle = 'white';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 3;
                ctx.fillText(`${t.damage}|${t.attackSpeed}|${t.debuff}`, x+8, y+20);
                ctx.shadowBlur = 0;
            }
        }

        function drawEnemies() {
            for (let e of enemies) {
                ctx.fillStyle = e.color;
                ctx.beginPath();
                ctx.arc(e.x, e.y, 12, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.font = '12px "MS Sans Serif"';
                ctx.fillText(`‚ù§Ô∏è${Math.floor(e.hp)}`, e.x-20, e.y-20);
                if (e.slowFactor < 1) {
                    ctx.fillStyle = '#aaffaa80';
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, 16, 0, Math.PI*2);
                    ctx.fill();
                }
                if (e.burnTimer > 0) {
                    ctx.fillStyle = '#ff880080';
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, 14, 0, Math.PI*2);
                    ctx.fill();
                }
            }
        }

        function draw() {
            drawGrid();
            drawTowers();
            drawEnemies();
            if (startDelay > 0) {
                ctx.fillStyle = 'black';
                ctx.font = '20px "MS Sans Serif"';
                ctx.fillText(`‚è≥ –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞: ${Math.ceil(startDelay / 60)} —Å–µ–∫`, 50, 80);
            }
            if (waypoints.length > 0) {
                ctx.fillStyle = 'black';
                ctx.font = '16px "MS Sans Serif"';
                ctx.fillText('üö™ –°—Ç–∞—Ä—Ç', waypoints[0].col * CELL_SIZE + 25, waypoints[0].row * CELL_SIZE + 55);
            }
        }

        // ---------- –ò–ì–†–û–í–û–ô –¶–ò–ö–õ ----------
        function gameLoop() {
            if (gameOver) {
                requestAnimationFrame(gameLoop);
                return;
            }

            frame++;

            if (startDelay > 0) {
                startDelay--;
                draw();
                updateUI();
                requestAnimationFrame(gameLoop);
                return;
            }

            spawnCounter++;
            if (spawnCounter >= spawnDelay && enemiesSpawnedThisWave < enemiesPerWave) {
                spawnCounter = 0;
                let r = Math.random();
                let type;
                if (wave < 3) type = 0;
                else {
                    if (r < 0.5) type = 0;
                    else if (r < 0.8) type = 1;
                    else type = 2;
                }
                enemies.push(new Enemy(type, waypoints, wave));
                enemiesSpawnedThisWave++;
            }

            for (let t of towers) t.update();

            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                e.move();
                e.updateEffects();

                if (e.isTooOld() && !e.isAtBase()) {
                    baseHealth -= 15;
                    playSound('basehit');
                    if (baseHealth < 0) baseHealth = 0;
                    enemies.splice(i, 1);
                    continue;
                }

                if (e.isAtBase()) {
                    baseHealth -= 15;
                    playSound('basehit');
                    if (baseHealth < 0) baseHealth = 0;
                    enemies.splice(i, 1);
                    continue;
                }

                if (!e.isAlive()) {
                    money += e.reward;
                    playSound('kill');
                    enemies.splice(i, 1);
                }
            }

            if (enemiesSpawnedThisWave >= enemiesPerWave && enemies.length === 0) {
                wave++;
                if (wave > maxWaveRecord) {
                    maxWaveRecord = wave;
                    localStorage.setItem('sonktd_maxwave', maxWaveRecord);
                }
                enemiesSpawnedThisWave = 0;
                enemiesPerWave = Math.min(25, 8 + wave * 2);
                spawnDelay = Math.max(20, 50 - wave * 2);
                money += 50 + wave * 5;
            }

            if (baseHealth <= 0) {
                gameOver = true;
                baseHealth = 0;
                alert('üòµ –ë–ê–ó–ê –£–ù–ò–ß–¢–û–ñ–ï–ù–ê! –ù–∞–∂–º–∏—Ç–µ "–ù–æ–≤–∞—è –∏–≥—Ä–∞".');
            }

            draw();
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            document.getElementById('moneyDisplay').innerText = Math.floor(money);
            document.getElementById('baseHealthDisplay').innerText = Math.floor(baseHealth);
            const percent = Math.max(0, (baseHealth / maxBaseHealth) * 100);
            document.getElementById('baseHealthFill').style.width = percent + '%';
            document.getElementById('waveDisplay').innerText = wave;
            document.getElementById('recordDisplay').innerText = maxWaveRecord;
        }

        // ---------- –ü–û–ö–£–ü–ö–ê –ò –ê–ü–ì–†–ï–ô–î ----------
        canvas.addEventListener('click', (e) => {
            if (gameOver) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (e.clientX - rect.left) * scaleX;
            const canvasY = (e.clientY - rect.top) * scaleY;

            const col = Math.floor((canvasX - 20) / CELL_SIZE);
            const row = Math.floor((canvasY - 20) / CELL_SIZE);
            if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return;

            const towerHere = towers.find(t => t.col === col && t.row === row);
            if (towerHere) {
                selectedTowerForUpgrade = towerHere;
                showUpgradePanel(towerHere);
                return;
            }

            if (gridMap[row][col] !== 0) {
                alert('‚ùå –ù–µ–ª—å–∑—è —Å—Ç—Ä–æ–∏—Ç—å –Ω–∞ –ø—É—Ç–∏ –∏–ª–∏ –±–∞–∑–µ!');
                return;
            }
            if (towers.some(t => t.col === col && t.row === row)) return;

            const towerType = selectedTowerIndex;
            const price = TOWER_TYPES[towerType].price;

            if (towers.length === 0) {
                towers.push(new Tower(col, row, towerType));
                playSound('buy');
            } else {
                if (money < price) {
                    alert('üí∞ –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç!');
                    return;
                }
                money -= price;
                towers.push(new Tower(col, row, towerType));
                playSound('buy');
            }
        });

        function showUpgradePanel(tower) {
            document.getElementById('upgradePanel').style.display = 'block';
            let attackIntervalSec = (2 / tower.attackSpeed).toFixed(2);
            document.getElementById('selectedTowerInfo').innerHTML = 
                `–ë–∞—à–Ω—è: ${tower.baseType.name}<br>
                üí• –£—Ä–æ–Ω ${tower.damage} (–º–∞–∫—Å ${tower.baseType.damage+5})<br>
                ‚ö° –°–∫.–∞—Ç–∞–∫–∏ ${tower.attackSpeed} (–∏–Ω—Ç–µ—Ä–≤–∞–ª ${attackIntervalSec} —Å–µ–∫, –º–∞–∫—Å ${tower.baseType.attackSpeed+5})<br>
                üß™ –î–µ–±–∞—Ñ—Ñ ${tower.debuff} (–º–∞–∫—Å ${tower.baseType.debuff+5})`;
            document.getElementById('upgradeDamageBtn').onclick = () => upgradeTowerStat(tower, 'damage');
            document.getElementById('upgradeSpeedBtn').onclick = () => upgradeTowerStat(tower, 'speed');
            document.getElementById('upgradeDebuffBtn').onclick = () => upgradeTowerStat(tower, 'debuff');
        }

        function upgradeTowerStat(tower, stat) {
            if (gameOver) return;
            let success = false;
            if (stat === 'damage' && money >= tower.upgradeDamageCost) {
                if (tower.upgradeDamage()) { money -= tower.upgradeDamageCost; success = true; }
                else alert('–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å —É—Ä–æ–Ω–∞!');
            } else if (stat === 'speed' && money >= tower.upgradeSpeedCost) {
                if (tower.upgradeAttackSpeed()) { money -= tower.upgradeSpeedCost; success = true; }
                else alert('–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –∞—Ç–∞–∫–∏!');
            } else if (stat === 'debuff' && money >= tower.upgradeDebuffCost) {
                if (tower.upgradeDebuff()) { money -= tower.upgradeDebuffCost; success = true; }
                else alert('–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –¥–µ–±–∞—Ñ—Ñ!');
            } else {
                alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç!');
            }
            if (success) {
                playSound('buy');
                showUpgradePanel(tower);
                updateUI();
            }
        }

        window.selectTower = function(index) {
            selectedTowerIndex = index;
            alert(`–í—ã–±—Ä–∞–Ω —Ç–∏–ø: ${TOWER_TYPES[index].name}`);
        };

        window.restartGame = function() {
            gameOver = false;
            money = 200;
            baseHealth = 100;
            towers = [];
            enemies = [];
            wave = 1;
            enemiesSpawnedThisWave = 0;
            enemiesPerWave = 8;
            spawnDelay = 50;
            spawnCounter = 0;
            startDelay = 120;
            selectedTowerForUpgrade = null;
            document.getElementById('upgradePanel').style.display = 'none';
            updateUI();
        };

        window.onload = function() {
            restartGame();
            requestAnimationFrame(gameLoop);
        };
    </script>
</body>
</html>